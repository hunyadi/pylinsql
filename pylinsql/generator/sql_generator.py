import dataclasses
import types
from typing import Dict, List, Optional, TextIO, Type, TypeVar

from pylinsql.generator.conversion import (
    python_to_sql_type,
    sql_quoted_id,
    sql_quoted_str,
)
from pylinsql.generator.inspection import entity_classes
from pylinsql.generator.schema import DataClass, ForeignKey, PrimaryKey
from pylinsql.query.base import is_dataclass_type
from strong_typing.docstring import parse_type
from strong_typing.inspection import is_type_optional, unwrap_optional_type

T = TypeVar("T")


def module_to_sql_stream(module: types.ModuleType, target: TextIO) -> None:
    classes = entity_classes(module)
    for cls in classes.values():
        class_to_sql_stream(cls, target)
        print("\n\n", file=target)


class ForeignKeyDependencyResolver:
    "Discovers data classes referenced via foreign key definitions."

    def __init__(self, classes: Dict[str, type]):
        self.classes = classes

    def find(self, cls: type) -> List[type]:
        result = []

        if is_dataclass_type(cls):
            for field in dataclasses.fields(cls):
                foreign_key = _get_foreign_key(field)
                if foreign_key is not None:
                    typ = self.classes.get(foreign_key.references.table)
                    if typ is not None:
                        result.append(typ)

        return result


def class_to_sql_stream(cls: DataClass[T], target: TextIO) -> None:
    SQLConverter(cls).write(target)


def _get_primary_key(cls: type) -> Optional[PrimaryKey]:
    primary_key = getattr(cls, "primary_key", None)
    return primary_key  # perform implicit type cast


def _get_foreign_key(field: dataclasses.Field) -> Optional[ForeignKey]:
    foreign_key = field.metadata.get("foreign_key")
    return foreign_key  # perform implicit type cast


class SQLConverter:
    def __init__(self, cls: T):
        self.cls = cls
        self.docs = parse_type(cls)

    def _get_field_description(self, field: dataclasses.Field) -> Optional[str]:
        description = field.metadata.get("description")
        if description is not None:
            return description

        param = self.docs.params.get(field.name)
        if param is not None:
            return param.description

        return None

    def write(self, target: TextIO) -> None:
        defs: List[str] = []
        comments: List[str] = []
        constraints: List[str] = []

        class_sql_name = sql_quoted_id(self.cls.__name__)

        primary_key_column = None
        primary_key = _get_primary_key(self.cls)
        if primary_key is not None:
            if isinstance(primary_key.column, str):
                column_list = sql_quoted_id(primary_key.column)
                primary_key_column = primary_key.column
            elif isinstance(primary_key.column, list):
                column_list = ", ".join(sql_quoted_id(id) for id in primary_key.column)

            constraints.append(
                f'CONSTRAINT "{primary_key.name}" PRIMARY KEY ({column_list})'
            )

        for field in dataclasses.fields(self.cls):
            field_sql_name = sql_quoted_id(field.name)

            if field.name == primary_key_column:
                sql_inner_type = python_to_sql_type(field.type)
                sql_type = f"{sql_inner_type} GENERATED BY DEFAULT AS IDENTITY"
            elif is_type_optional(field.type):
                sql_type = python_to_sql_type(unwrap_optional_type(field.type))
            else:
                sql_inner_type = python_to_sql_type(field.type)
                sql_type = f"{sql_inner_type} NOT NULL"
            defs.append(f"{field_sql_name} {sql_type}")

            description = self._get_field_description(field)
            if description is not None:
                comments.append(
                    f"COMMENT ON COLUMN {class_sql_name}.{field_sql_name} IS {sql_quoted_str(description)};"
                )

            foreign_key = _get_foreign_key(field)
            if foreign_key is not None:
                fk_sql_name = sql_quoted_id(foreign_key.name)
                pk_sql_table = sql_quoted_id(foreign_key.references.table)
                pk_sql_column = sql_quoted_id(foreign_key.references.column)
                constraints.append(
                    f"CONSTRAINT {fk_sql_name} FOREIGN KEY ({field_sql_name}) REFERENCES {pk_sql_table}({pk_sql_column})"
                )

        defs.extend(constraints)
        print(f"CREATE TABLE {class_sql_name}(", file=target)
        print(",\n".join(defs), file=target)
        print(f");", file=target)

        description = self.docs.full_description
        if description is not None:
            print(
                f"COMMENT ON TABLE {class_sql_name} IS {sql_quoted_str(description)};",
                file=target,
            )
        for comment in comments:
            print(comment, file=target)
